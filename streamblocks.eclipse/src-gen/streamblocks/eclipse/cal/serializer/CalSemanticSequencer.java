/*
 * generated by Xtext 2.21.0
 */
package streamblocks.eclipse.cal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import streamblocks.eclipse.cal.cal.AstAction;
import streamblocks.eclipse.cal.cal.AstActor;
import streamblocks.eclipse.cal.cal.AstAnnotation;
import streamblocks.eclipse.cal.cal.AstAnnotationArgument;
import streamblocks.eclipse.cal.cal.AstAssignParameter;
import streamblocks.eclipse.cal.cal.AstConnectionAttribute;
import streamblocks.eclipse.cal.cal.AstEntity;
import streamblocks.eclipse.cal.cal.AstEntityIfExpr;
import streamblocks.eclipse.cal.cal.AstEntityInstanceExpr;
import streamblocks.eclipse.cal.cal.AstEntityListExpr;
import streamblocks.eclipse.cal.cal.AstEntityVariable;
import streamblocks.eclipse.cal.cal.AstEntityVariableReference;
import streamblocks.eclipse.cal.cal.AstExpressionAlternative;
import streamblocks.eclipse.cal.cal.AstExpressionAssertion;
import streamblocks.eclipse.cal.cal.AstExpressionBinary;
import streamblocks.eclipse.cal.cal.AstExpressionBoolean;
import streamblocks.eclipse.cal.cal.AstExpressionCase;
import streamblocks.eclipse.cal.cal.AstExpressionElsif;
import streamblocks.eclipse.cal.cal.AstExpressionFloat;
import streamblocks.eclipse.cal.cal.AstExpressionIf;
import streamblocks.eclipse.cal.cal.AstExpressionInteger;
import streamblocks.eclipse.cal.cal.AstExpressionLambda;
import streamblocks.eclipse.cal.cal.AstExpressionLet;
import streamblocks.eclipse.cal.cal.AstExpressionList;
import streamblocks.eclipse.cal.cal.AstExpressionMap;
import streamblocks.eclipse.cal.cal.AstExpressionProc;
import streamblocks.eclipse.cal.cal.AstExpressionSet;
import streamblocks.eclipse.cal.cal.AstExpressionString;
import streamblocks.eclipse.cal.cal.AstExpressionSymbolReference;
import streamblocks.eclipse.cal.cal.AstExpressionUnary;
import streamblocks.eclipse.cal.cal.AstExternalActor;
import streamblocks.eclipse.cal.cal.AstForeachGenerator;
import streamblocks.eclipse.cal.cal.AstFunction;
import streamblocks.eclipse.cal.cal.AstGenerator;
import streamblocks.eclipse.cal.cal.AstInequality;
import streamblocks.eclipse.cal.cal.AstInitialize;
import streamblocks.eclipse.cal.cal.AstInputPattern;
import streamblocks.eclipse.cal.cal.AstInvariant;
import streamblocks.eclipse.cal.cal.AstLValue;
import streamblocks.eclipse.cal.cal.AstMemberAccess;
import streamblocks.eclipse.cal.cal.AstNamespace;
import streamblocks.eclipse.cal.cal.AstNetwork;
import streamblocks.eclipse.cal.cal.AstOutputExpression;
import streamblocks.eclipse.cal.cal.AstPattern;
import streamblocks.eclipse.cal.cal.AstPort;
import streamblocks.eclipse.cal.cal.AstPriority;
import streamblocks.eclipse.cal.cal.AstProcedure;
import streamblocks.eclipse.cal.cal.AstProcessDescription;
import streamblocks.eclipse.cal.cal.AstSchedule;
import streamblocks.eclipse.cal.cal.AstState;
import streamblocks.eclipse.cal.cal.AstStatementAlternative;
import streamblocks.eclipse.cal.cal.AstStatementAssign;
import streamblocks.eclipse.cal.cal.AstStatementBlock;
import streamblocks.eclipse.cal.cal.AstStatementCall;
import streamblocks.eclipse.cal.cal.AstStatementCase;
import streamblocks.eclipse.cal.cal.AstStatementElsif;
import streamblocks.eclipse.cal.cal.AstStatementForeach;
import streamblocks.eclipse.cal.cal.AstStatementIf;
import streamblocks.eclipse.cal.cal.AstStatementRead;
import streamblocks.eclipse.cal.cal.AstStatementWhile;
import streamblocks.eclipse.cal.cal.AstStatementWrite;
import streamblocks.eclipse.cal.cal.AstStructure;
import streamblocks.eclipse.cal.cal.AstStructureStatementConnection;
import streamblocks.eclipse.cal.cal.AstStructureStatementElsif;
import streamblocks.eclipse.cal.cal.AstStructureStatementForeach;
import streamblocks.eclipse.cal.cal.AstStructureStatementIf;
import streamblocks.eclipse.cal.cal.AstTag;
import streamblocks.eclipse.cal.cal.AstTaggedTuple;
import streamblocks.eclipse.cal.cal.AstTransition;
import streamblocks.eclipse.cal.cal.AstTuple;
import streamblocks.eclipse.cal.cal.AstType;
import streamblocks.eclipse.cal.cal.AstTypeDefinitionParameter;
import streamblocks.eclipse.cal.cal.AstTypeParam;
import streamblocks.eclipse.cal.cal.AstTypeParameterList;
import streamblocks.eclipse.cal.cal.AstTypeUser;
import streamblocks.eclipse.cal.cal.AstVariable;
import streamblocks.eclipse.cal.cal.CalPackage;
import streamblocks.eclipse.cal.cal.GroupImportTail;
import streamblocks.eclipse.cal.cal.Mapping;
import streamblocks.eclipse.cal.cal.RegExp;
import streamblocks.eclipse.cal.cal.RegExpBinary;
import streamblocks.eclipse.cal.cal.RegExpTag;
import streamblocks.eclipse.cal.cal.RegExpUnary;
import streamblocks.eclipse.cal.cal.RvcImport;
import streamblocks.eclipse.cal.cal.SingleImportTail;
import streamblocks.eclipse.cal.services.CalGrammarAccess;

@SuppressWarnings("all")
public class CalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CalPackage.AST_ACTION:
				sequence_AstAction(context, (AstAction) semanticObject); 
				return; 
			case CalPackage.AST_ACTOR:
				sequence_AstActor(context, (AstActor) semanticObject); 
				return; 
			case CalPackage.AST_ANNOTATION:
				sequence_AstAnnotation(context, (AstAnnotation) semanticObject); 
				return; 
			case CalPackage.AST_ANNOTATION_ARGUMENT:
				sequence_AstAnnotationArgument(context, (AstAnnotationArgument) semanticObject); 
				return; 
			case CalPackage.AST_ASSIGN_PARAMETER:
				sequence_AstAssignParameter(context, (AstAssignParameter) semanticObject); 
				return; 
			case CalPackage.AST_CONNECTION_ATTRIBUTE:
				sequence_AstConnectionAttribute(context, (AstConnectionAttribute) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY:
				sequence_AstEntity(context, (AstEntity) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY_IF_EXPR:
				sequence_AstEntityIfExpr(context, (AstEntityIfExpr) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY_INSTANCE_EXPR:
				sequence_AstEntityInstanceExpr(context, (AstEntityInstanceExpr) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY_LIST_EXPR:
				sequence_AstEntityListExpr(context, (AstEntityListExpr) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY_VARIABLE:
				sequence_AstEntityDeclaration(context, (AstEntityVariable) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY_VARIABLE_REFERENCE:
				sequence_AstEntityVariableReference(context, (AstEntityVariableReference) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_ALTERNATIVE:
				sequence_AstExpressionAlternative(context, (AstExpressionAlternative) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_ASSERTION:
				sequence_AstExpressionAssertion(context, (AstExpressionAssertion) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_BINARY:
				sequence_AstExpression_AstExpressionAdditive_AstExpressionAnd_AstExpressionBitand_AstExpressionBitor_AstExpressionBitxor_AstExpressionEq_AstExpressionExp_AstExpressionMultiplicative_AstExpressionRelational_AstExpressionShift(context, (AstExpressionBinary) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_BOOLEAN:
				sequence_AstExpressionBoolean(context, (AstExpressionBoolean) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_CASE:
				sequence_AstExpressionCase(context, (AstExpressionCase) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_ELSIF:
				sequence_AstExpressionElsif(context, (AstExpressionElsif) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_FLOAT:
				sequence_AstExpressionFloat(context, (AstExpressionFloat) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_IF:
				sequence_AstExpressionIf(context, (AstExpressionIf) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_INTEGER:
				sequence_AstExpressionInteger(context, (AstExpressionInteger) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_LAMBDA:
				sequence_AstExpressionLambda(context, (AstExpressionLambda) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_LET:
				sequence_AstExpressionLet(context, (AstExpressionLet) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_LIST:
				sequence_AstExpressionList(context, (AstExpressionList) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_MAP:
				sequence_AstExpressionMap(context, (AstExpressionMap) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_PROC:
				sequence_AstExpressionProc(context, (AstExpressionProc) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_SET:
				sequence_AstExpressionSet(context, (AstExpressionSet) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_STRING:
				sequence_AstExpressionString(context, (AstExpressionString) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_SYMBOL_REFERENCE:
				sequence_AstExpressionSymbolReference(context, (AstExpressionSymbolReference) semanticObject); 
				return; 
			case CalPackage.AST_EXPRESSION_UNARY:
				sequence_AstExpressionUnary(context, (AstExpressionUnary) semanticObject); 
				return; 
			case CalPackage.AST_EXTERNAL_ACTOR:
				sequence_AstExternalActor(context, (AstExternalActor) semanticObject); 
				return; 
			case CalPackage.AST_FOREACH_GENERATOR:
				sequence_AstForeachGenerator(context, (AstForeachGenerator) semanticObject); 
				return; 
			case CalPackage.AST_FUNCTION:
				if (rule == grammarAccess.getAstExternalFunctionRule()) {
					sequence_AstExternalFunction(context, (AstFunction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstFunctionRule()) {
					sequence_AstFunction(context, (AstFunction) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_GENERATOR:
				sequence_AstGenerator(context, (AstGenerator) semanticObject); 
				return; 
			case CalPackage.AST_INEQUALITY:
				sequence_AstInequality(context, (AstInequality) semanticObject); 
				return; 
			case CalPackage.AST_INITIALIZE:
				sequence_AstInitialize(context, (AstInitialize) semanticObject); 
				return; 
			case CalPackage.AST_INPUT_PATTERN:
				sequence_AstInputPattern(context, (AstInputPattern) semanticObject); 
				return; 
			case CalPackage.AST_INVARIANT:
				sequence_AstInvariant(context, (AstInvariant) semanticObject); 
				return; 
			case CalPackage.AST_LVALUE:
				sequence_AstLValue(context, (AstLValue) semanticObject); 
				return; 
			case CalPackage.AST_MEMBER_ACCESS:
				sequence_AstMemberAccess(context, (AstMemberAccess) semanticObject); 
				return; 
			case CalPackage.AST_NAMESPACE:
				if (rule == grammarAccess.getAstNamespaceRule()) {
					sequence_AstNamespace(context, (AstNamespace) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCompilationUnitRule()) {
					sequence_AstNamespace_AstPackage(context, (AstNamespace) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPackageRule()) {
					sequence_AstPackage(context, (AstNamespace) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstUnitRule()) {
					sequence_AstUnit(context, (AstNamespace) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_NETWORK:
				sequence_AstNetwork(context, (AstNetwork) semanticObject); 
				return; 
			case CalPackage.AST_OUTPUT_EXPRESSION:
				sequence_AstOutputExpression(context, (AstOutputExpression) semanticObject); 
				return; 
			case CalPackage.AST_PATTERN:
				if (rule == grammarAccess.getAstPatternAliasRule()) {
					sequence_AstPatternAlias(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternRule()) {
					sequence_AstPatternAlias_AstPatternAlternative_AstPatternDeclaration_AstPatternDeconstruction_AstPatternList_AstPatternWildcard(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternAlternativeRule()) {
					sequence_AstPatternAlternative(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternDeclarationRule()) {
					sequence_AstPatternDeclaration(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternDeconstructionRule()) {
					sequence_AstPatternDeconstruction(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternExpressionRule()) {
					sequence_AstPatternExpression(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternListRule()) {
					sequence_AstPatternList(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternLiteralRule()) {
					sequence_AstPatternLiteral(context, (AstPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstPatternWildcardRule()) {
					sequence_AstPatternWildcard(context, (AstPattern) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_PORT:
				sequence_AstPort(context, (AstPort) semanticObject); 
				return; 
			case CalPackage.AST_PRIORITY:
				sequence_AstPriority(context, (AstPriority) semanticObject); 
				return; 
			case CalPackage.AST_PROCEDURE:
				if (rule == grammarAccess.getAstExternalProcedureRule()) {
					sequence_AstExternalProcedure(context, (AstProcedure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstProcedureRule()) {
					sequence_AstProcedure(context, (AstProcedure) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_PROCESS_DESCRIPTION:
				sequence_AstProcessDescription(context, (AstProcessDescription) semanticObject); 
				return; 
			case CalPackage.AST_SCHEDULE:
				sequence_AstSchedule(context, (AstSchedule) semanticObject); 
				return; 
			case CalPackage.AST_STATE:
				sequence_AstState(context, (AstState) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_ALTERNATIVE:
				sequence_AstStatementAlternative(context, (AstStatementAlternative) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_ASSIGN:
				sequence_AstStatementAssign(context, (AstStatementAssign) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_BLOCK:
				sequence_AstStatementBlock(context, (AstStatementBlock) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_CALL:
				sequence_AstStatementCall(context, (AstStatementCall) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_CASE:
				sequence_AstStatementCase(context, (AstStatementCase) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_ELSIF:
				sequence_AstStatementElsif(context, (AstStatementElsif) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_FOREACH:
				sequence_AstStatementForeach(context, (AstStatementForeach) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_IF:
				sequence_AstStatementIf(context, (AstStatementIf) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_READ:
				sequence_AstStatementRead(context, (AstStatementRead) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_WHILE:
				sequence_AstStatementWhile(context, (AstStatementWhile) semanticObject); 
				return; 
			case CalPackage.AST_STATEMENT_WRITE:
				sequence_AstStatementWrite(context, (AstStatementWrite) semanticObject); 
				return; 
			case CalPackage.AST_STRUCTURE:
				sequence_AstStructure(context, (AstStructure) semanticObject); 
				return; 
			case CalPackage.AST_STRUCTURE_STATEMENT_CONNECTION:
				sequence_AstStructureStatementConnection(context, (AstStructureStatementConnection) semanticObject); 
				return; 
			case CalPackage.AST_STRUCTURE_STATEMENT_ELSIF:
				sequence_AstStructureStatementElsif(context, (AstStructureStatementElsif) semanticObject); 
				return; 
			case CalPackage.AST_STRUCTURE_STATEMENT_FOREACH:
				sequence_AstStructureStatementForeach(context, (AstStructureStatementForeach) semanticObject); 
				return; 
			case CalPackage.AST_STRUCTURE_STATEMENT_IF:
				sequence_AstStructureStatementIf(context, (AstStructureStatementIf) semanticObject); 
				return; 
			case CalPackage.AST_TAG:
				sequence_AstTag(context, (AstTag) semanticObject); 
				return; 
			case CalPackage.AST_TAGGED_TUPLE:
				sequence_AstTaggedTuple(context, (AstTaggedTuple) semanticObject); 
				return; 
			case CalPackage.AST_TRANSITION:
				sequence_AstTransition(context, (AstTransition) semanticObject); 
				return; 
			case CalPackage.AST_TUPLE:
				sequence_AstTuple(context, (AstTuple) semanticObject); 
				return; 
			case CalPackage.AST_TYPE:
				sequence_AstType(context, (AstType) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_DEFINITION_PARAMETER:
				sequence_AstTypeDefinitionParameter(context, (AstTypeDefinitionParameter) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_PARAM:
				sequence_AstTypeParam(context, (AstTypeParam) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_PARAMETER_LIST:
				sequence_AstTypeParameterList(context, (AstTypeParameterList) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_USER:
				if (rule == grammarAccess.getAstTypeDefinitionTypeParameterRule()) {
					sequence_AstTypeDefinitionTypeParameter(context, (AstTypeUser) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstTypeDefinitionRule()) {
					sequence_AstTypeDefinition(context, (AstTypeUser) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstTypeUserRule()) {
					sequence_AstTypeUser(context, (AstTypeUser) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_VARIABLE:
				if (rule == grammarAccess.getAstConstantVariableRule()) {
					sequence_AstConstantVariable_AstVariableDeclaration(context, (AstVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstParameterRule()) {
					sequence_AstParameter_AstVariableDeclaration(context, (AstVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstTokenRule()) {
					sequence_AstToken(context, (AstVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstStateVariableRule()
						|| rule == grammarAccess.getAstValuedVariableDeclarationRule()) {
					sequence_AstValuedVariableDeclaration_AstVariableDeclaration(context, (AstVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAstExternalVariableRule()
						|| rule == grammarAccess.getAstVariableDeclarationRule()) {
					sequence_AstVariableDeclaration(context, (AstVariable) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.GROUP_IMPORT_TAIL:
				sequence_GroupImportTail(context, (GroupImportTail) semanticObject); 
				return; 
			case CalPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case CalPackage.REG_EXP:
				sequence_AstScheduleRegExp(context, (RegExp) semanticObject); 
				return; 
			case CalPackage.REG_EXP_BINARY:
				sequence_RegExp_RegExpConcatenation(context, (RegExpBinary) semanticObject); 
				return; 
			case CalPackage.REG_EXP_TAG:
				sequence_RegExpTerminal(context, (RegExpTag) semanticObject); 
				return; 
			case CalPackage.REG_EXP_UNARY:
				sequence_RegExpPostfix(context, (RegExpUnary) semanticObject); 
				return; 
			case CalPackage.RVC_IMPORT:
				sequence_RvcImport(context, (RvcImport) semanticObject); 
				return; 
			case CalPackage.SINGLE_IMPORT_TAIL:
				sequence_SingleImportTail(context, (SingleImportTail) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AstAction returns AstAction
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         tag=AstTag? 
	 *         (inputs+=AstInputPattern inputs+=AstInputPattern*)? 
	 *         (outputs+=AstOutputExpression outputs+=AstOutputExpression*)? 
	 *         (guards+=AstExpression guards+=AstExpression*)? 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStatement*
	 *     )
	 */
	protected void sequence_AstAction(ISerializationContext context, AstAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAbstractActor returns AstActor
	 *     AstActor returns AstActor
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=AstParameter parameters+=AstParameter*)? 
	 *         (inputs+=AstPort inputs+=AstPort*)? 
	 *         (outputs+=AstPort outputs+=AstPort*)? 
	 *         invariants+=AstInvariant? 
	 *         (
	 *             (
	 *                 functions+=AstFunction | 
	 *                 procedures+=AstProcedure | 
	 *                 actions+=AstAction | 
	 *                 processes+=AstProcessDescription | 
	 *                 initializes+=AstInitialize | 
	 *                 stateVariables+=AstStateVariable
	 *             )? 
	 *             invariants+=AstInvariant?
	 *         )* 
	 *         (schedules=AstSchedule | scheduleRegExp=AstScheduleRegExp)? 
	 *         priorities+=AstPriority*
	 *     )
	 */
	protected void sequence_AstActor(ISerializationContext context, AstActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAnnotationArgument returns AstAnnotationArgument
	 *
	 * Constraint:
	 *     (name=ID value=STRING)
	 */
	protected void sequence_AstAnnotationArgument(ISerializationContext context, AstAnnotationArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ANNOTATION_ARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ANNOTATION_ARGUMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ANNOTATION_ARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ANNOTATION_ARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstAnnotationArgumentAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAstAnnotationArgumentAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstAnnotation returns AstAnnotation
	 *
	 * Constraint:
	 *     (name=ID (arguments+=AstAnnotationArgument arguments+=AstAnnotationArgument*)?)
	 */
	protected void sequence_AstAnnotation(ISerializationContext context, AstAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAssignParameter returns AstAssignParameter
	 *
	 * Constraint:
	 *     (name=ID value=AstExpression)
	 */
	protected void sequence_AstAssignParameter(ISerializationContext context, AstAssignParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ASSIGN_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ASSIGN_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ASSIGN_PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ASSIGN_PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstAssignParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAstAssignParameterAccess().getValueAstExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstConnectionAttribute returns AstConnectionAttribute
	 *
	 * Constraint:
	 *     (name=ID value=AstExpression)
	 */
	protected void sequence_AstConnectionAttribute(ISerializationContext context, AstConnectionAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_CONNECTION_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_CONNECTION_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_CONNECTION_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_CONNECTION_ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstConnectionAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAstConnectionAttributeAccess().getValueAstExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstConstantVariable returns AstVariable
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         type=AstType 
	 *         name=ID 
	 *         dimensions+=AstExpression* 
	 *         constant?='=' 
	 *         value=AstExpression
	 *     )
	 */
	protected void sequence_AstConstantVariable_AstVariableDeclaration(ISerializationContext context, AstVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstEntityDeclaration returns AstEntityVariable
	 *
	 * Constraint:
	 *     (name=ID entity=AstEntityExpr)
	 */
	protected void sequence_AstEntityDeclaration(ISerializationContext context, AstEntityVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstEntityDeclarationAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAstEntityDeclarationAccess().getEntityAstEntityExprParserRuleCall_2_0(), semanticObject.getEntity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstEntityExpr returns AstEntityIfExpr
	 *     AstEntityIfExpr returns AstEntityIfExpr
	 *
	 * Constraint:
	 *     (condition=AstExpression trueEntity=AstEntityExpr falseEntity=AstEntityExpr)
	 */
	protected void sequence_AstEntityIfExpr(ISerializationContext context, AstEntityIfExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__CONDITION));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__TRUE_ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__TRUE_ENTITY));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__FALSE_ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_IF_EXPR__FALSE_ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstEntityIfExprAccess().getConditionAstExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getAstEntityIfExprAccess().getTrueEntityAstEntityExprParserRuleCall_3_0(), semanticObject.getTrueEntity());
		feeder.accept(grammarAccess.getAstEntityIfExprAccess().getFalseEntityAstEntityExprParserRuleCall_5_0(), semanticObject.getFalseEntity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstEntityExpr returns AstEntityInstanceExpr
	 *     AstEntityInstanceExpr returns AstEntityInstanceExpr
	 *
	 * Constraint:
	 *     (type=[AstEntity|QualifiedName] (parameters+=AstAssignParameter parameters+=AstAssignParameter*)?)
	 */
	protected void sequence_AstEntityInstanceExpr(ISerializationContext context, AstEntityInstanceExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstEntityExpr returns AstEntityListExpr
	 *     AstEntityListExpr returns AstEntityListExpr
	 *
	 * Constraint:
	 *     (exprs+=AstEntityExpr exprs+=AstEntityExpr* generator=AstGenerator?)
	 */
	protected void sequence_AstEntityListExpr(ISerializationContext context, AstEntityListExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstEntityVariableReference returns AstEntityVariableReference
	 *
	 * Constraint:
	 *     variable=[AstEntityVariable|ID]
	 */
	protected void sequence_AstEntityVariableReference(ISerializationContext context, AstEntityVariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE_REFERENCE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_ENTITY_VARIABLE_REFERENCE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstEntityVariableReferenceAccess().getVariableAstEntityVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(CalPackage.Literals.AST_ENTITY_VARIABLE_REFERENCE__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstEntity returns AstEntity
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* actor=AstAbstractActor)
	 */
	protected void sequence_AstEntity(ISerializationContext context, AstEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpressionAlternative returns AstExpressionAlternative
	 *
	 * Constraint:
	 *     (pattern=AstPattern (guards+=AstExpression guards+=AstExpression*)? expression=AstExpression)
	 */
	protected void sequence_AstExpressionAlternative(ISerializationContext context, AstExpressionAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionAssertion
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionAnd returns AstExpressionAssertion
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionBitor returns AstExpressionAssertion
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionBitxor returns AstExpressionAssertion
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionBitand returns AstExpressionAssertion
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionEq returns AstExpressionAssertion
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionRelational returns AstExpressionAssertion
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionShift returns AstExpressionAssertion
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionAdditive returns AstExpressionAssertion
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionMultiplicative returns AstExpressionAssertion
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionExp returns AstExpressionAssertion
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionAssertion
	 *     AstExpressionUnary returns AstExpressionAssertion
	 *     AstExpressionAssertion returns AstExpressionAssertion
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionAssertion
	 *     AstExpressionPostfix returns AstExpressionAssertion
	 *
	 * Constraint:
	 *     (target=AstExpressionAssertion_AstExpressionAssertion_1_0_0_0 type=AstType)
	 */
	protected void sequence_AstExpressionAssertion(ISerializationContext context, AstExpressionAssertion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_ASSERTION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_ASSERTION__TARGET));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_ASSERTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_ASSERTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstExpressionAssertionAccess().getAstExpressionAssertionTargetAction_1_0_0_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAstExpressionAssertionAccess().getTypeAstTypeParserRuleCall_1_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionBoolean
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionAnd returns AstExpressionBoolean
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionBitor returns AstExpressionBoolean
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionBitxor returns AstExpressionBoolean
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionBitand returns AstExpressionBoolean
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionEq returns AstExpressionBoolean
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionRelational returns AstExpressionBoolean
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionShift returns AstExpressionBoolean
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionAdditive returns AstExpressionBoolean
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionMultiplicative returns AstExpressionBoolean
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionExp returns AstExpressionBoolean
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionBoolean
	 *     AstExpressionUnary returns AstExpressionBoolean
	 *     AstExpressionAssertion returns AstExpressionBoolean
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionBoolean
	 *     AstExpressionPostfix returns AstExpressionBoolean
	 *     AstExpressionLiteral returns AstExpressionBoolean
	 *     AstExpressionBoolean returns AstExpressionBoolean
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_AstExpressionBoolean(ISerializationContext context, AstExpressionBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstExpressionBooleanAccess().getValueBOOLTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionCase
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionAnd returns AstExpressionCase
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionBitor returns AstExpressionCase
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionBitxor returns AstExpressionCase
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionBitand returns AstExpressionCase
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionEq returns AstExpressionCase
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionRelational returns AstExpressionCase
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionShift returns AstExpressionCase
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionAdditive returns AstExpressionCase
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionMultiplicative returns AstExpressionCase
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionExp returns AstExpressionCase
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionCase
	 *     AstExpressionUnary returns AstExpressionCase
	 *     AstExpressionAssertion returns AstExpressionCase
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionCase
	 *     AstExpressionPostfix returns AstExpressionCase
	 *     AstExpressionCase returns AstExpressionCase
	 *
	 * Constraint:
	 *     (expression=AstExpressionSymbolReference cases+=AstExpressionAlternative+ default=AstExpression?)
	 */
	protected void sequence_AstExpressionCase(ISerializationContext context, AstExpressionCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpressionElsif returns AstExpressionElsif
	 *
	 * Constraint:
	 *     (condition=AstExpression then=AstExpression)
	 */
	protected void sequence_AstExpressionElsif(ISerializationContext context, AstExpressionElsif semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_ELSIF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_ELSIF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_ELSIF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_ELSIF__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstExpressionElsifAccess().getConditionAstExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getAstExpressionElsifAccess().getThenAstExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionFloat
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionAnd returns AstExpressionFloat
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionBitor returns AstExpressionFloat
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionBitxor returns AstExpressionFloat
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionBitand returns AstExpressionFloat
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionEq returns AstExpressionFloat
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionRelational returns AstExpressionFloat
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionShift returns AstExpressionFloat
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionAdditive returns AstExpressionFloat
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionMultiplicative returns AstExpressionFloat
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionExp returns AstExpressionFloat
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionFloat
	 *     AstExpressionUnary returns AstExpressionFloat
	 *     AstExpressionAssertion returns AstExpressionFloat
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionFloat
	 *     AstExpressionPostfix returns AstExpressionFloat
	 *     AstExpressionLiteral returns AstExpressionFloat
	 *     AstExpressionFloat returns AstExpressionFloat
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_AstExpressionFloat(ISerializationContext context, AstExpressionFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstExpressionFloatAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionIf
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionAnd returns AstExpressionIf
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionBitor returns AstExpressionIf
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionBitxor returns AstExpressionIf
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionBitand returns AstExpressionIf
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionEq returns AstExpressionIf
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionRelational returns AstExpressionIf
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionShift returns AstExpressionIf
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionAdditive returns AstExpressionIf
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionMultiplicative returns AstExpressionIf
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionExp returns AstExpressionIf
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionIf
	 *     AstExpressionUnary returns AstExpressionIf
	 *     AstExpressionAssertion returns AstExpressionIf
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionIf
	 *     AstExpressionPostfix returns AstExpressionIf
	 *     AstExpressionIf returns AstExpressionIf
	 *
	 * Constraint:
	 *     (condition=AstExpression then=AstExpression elsifs+=AstExpressionElsif* else=AstExpression)
	 */
	protected void sequence_AstExpressionIf(ISerializationContext context, AstExpressionIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionInteger
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionAnd returns AstExpressionInteger
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionBitor returns AstExpressionInteger
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionBitxor returns AstExpressionInteger
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionBitand returns AstExpressionInteger
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionEq returns AstExpressionInteger
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionRelational returns AstExpressionInteger
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionShift returns AstExpressionInteger
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionAdditive returns AstExpressionInteger
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionMultiplicative returns AstExpressionInteger
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionExp returns AstExpressionInteger
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionInteger
	 *     AstExpressionUnary returns AstExpressionInteger
	 *     AstExpressionAssertion returns AstExpressionInteger
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionInteger
	 *     AstExpressionPostfix returns AstExpressionInteger
	 *     AstExpressionLiteral returns AstExpressionInteger
	 *     AstExpressionInteger returns AstExpressionInteger
	 *
	 * Constraint:
	 *     (value=DECIMAL | value=OCTAL | value=HEX)
	 */
	protected void sequence_AstExpressionInteger(ISerializationContext context, AstExpressionInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionLambda
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionAnd returns AstExpressionLambda
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionBitor returns AstExpressionLambda
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionBitxor returns AstExpressionLambda
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionBitand returns AstExpressionLambda
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionEq returns AstExpressionLambda
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionRelational returns AstExpressionLambda
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionShift returns AstExpressionLambda
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionAdditive returns AstExpressionLambda
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionMultiplicative returns AstExpressionLambda
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionExp returns AstExpressionLambda
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionLambda
	 *     AstExpressionUnary returns AstExpressionLambda
	 *     AstExpressionAssertion returns AstExpressionLambda
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionLambda
	 *     AstExpressionPostfix returns AstExpressionLambda
	 *     AstExpressionLambda returns AstExpressionLambda
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)? 
	 *         type=AstType 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         expression=AstExpression
	 *     )
	 */
	protected void sequence_AstExpressionLambda(ISerializationContext context, AstExpressionLambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionLet
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionAnd returns AstExpressionLet
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionBitor returns AstExpressionLet
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionBitxor returns AstExpressionLet
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionBitand returns AstExpressionLet
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionEq returns AstExpressionLet
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionRelational returns AstExpressionLet
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionShift returns AstExpressionLet
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionAdditive returns AstExpressionLet
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionMultiplicative returns AstExpressionLet
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionExp returns AstExpressionLet
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionLet
	 *     AstExpressionUnary returns AstExpressionLet
	 *     AstExpressionAssertion returns AstExpressionLet
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionLet
	 *     AstExpressionPostfix returns AstExpressionLet
	 *     AstExpressionLet returns AstExpressionLet
	 *
	 * Constraint:
	 *     ((variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? expr=AstExpression)
	 */
	protected void sequence_AstExpressionLet(ISerializationContext context, AstExpressionLet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionList
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionAnd returns AstExpressionList
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionBitor returns AstExpressionList
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionBitxor returns AstExpressionList
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionBitand returns AstExpressionList
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionEq returns AstExpressionList
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionRelational returns AstExpressionList
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionShift returns AstExpressionList
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionAdditive returns AstExpressionList
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionMultiplicative returns AstExpressionList
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionExp returns AstExpressionList
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionList
	 *     AstExpressionUnary returns AstExpressionList
	 *     AstExpressionAssertion returns AstExpressionList
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionList
	 *     AstExpressionPostfix returns AstExpressionList
	 *     AstExpressionList returns AstExpressionList
	 *
	 * Constraint:
	 *     (expressions+=AstExpression expressions+=AstExpression* (generators+=AstGenerator generators+=AstGenerator*)?)
	 */
	protected void sequence_AstExpressionList(ISerializationContext context, AstExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionMap
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionAnd returns AstExpressionMap
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionBitor returns AstExpressionMap
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionBitxor returns AstExpressionMap
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionBitand returns AstExpressionMap
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionEq returns AstExpressionMap
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionRelational returns AstExpressionMap
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionShift returns AstExpressionMap
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionAdditive returns AstExpressionMap
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionMultiplicative returns AstExpressionMap
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionExp returns AstExpressionMap
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionMap
	 *     AstExpressionUnary returns AstExpressionMap
	 *     AstExpressionAssertion returns AstExpressionMap
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionMap
	 *     AstExpressionPostfix returns AstExpressionMap
	 *     AstExpressionMap returns AstExpressionMap
	 *
	 * Constraint:
	 *     ((mappings+=Mapping mappings+=Mapping*)? generator=AstGenerator?)
	 */
	protected void sequence_AstExpressionMap(ISerializationContext context, AstExpressionMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionProc
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionAnd returns AstExpressionProc
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionBitor returns AstExpressionProc
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionBitxor returns AstExpressionProc
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionBitand returns AstExpressionProc
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionEq returns AstExpressionProc
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionRelational returns AstExpressionProc
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionShift returns AstExpressionProc
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionAdditive returns AstExpressionProc
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionMultiplicative returns AstExpressionProc
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionExp returns AstExpressionProc
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionProc
	 *     AstExpressionUnary returns AstExpressionProc
	 *     AstExpressionAssertion returns AstExpressionProc
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionProc
	 *     AstExpressionPostfix returns AstExpressionProc
	 *     AstExpressionProc returns AstExpressionProc
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)? 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStatement*
	 *     )
	 */
	protected void sequence_AstExpressionProc(ISerializationContext context, AstExpressionProc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionSet
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionAnd returns AstExpressionSet
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionBitor returns AstExpressionSet
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionBitxor returns AstExpressionSet
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionBitand returns AstExpressionSet
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionEq returns AstExpressionSet
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionRelational returns AstExpressionSet
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionShift returns AstExpressionSet
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionAdditive returns AstExpressionSet
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionMultiplicative returns AstExpressionSet
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionExp returns AstExpressionSet
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionSet
	 *     AstExpressionUnary returns AstExpressionSet
	 *     AstExpressionAssertion returns AstExpressionSet
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionSet
	 *     AstExpressionPostfix returns AstExpressionSet
	 *     AstExpressionSet returns AstExpressionSet
	 *
	 * Constraint:
	 *     ((exprs+=AstExpression exprs+=AstExpression)? generator=AstGenerator?)
	 */
	protected void sequence_AstExpressionSet(ISerializationContext context, AstExpressionSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionString
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionAnd returns AstExpressionString
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionBitor returns AstExpressionString
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionBitxor returns AstExpressionString
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionBitand returns AstExpressionString
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionEq returns AstExpressionString
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionRelational returns AstExpressionString
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionShift returns AstExpressionString
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionAdditive returns AstExpressionString
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionMultiplicative returns AstExpressionString
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionExp returns AstExpressionString
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionString
	 *     AstExpressionUnary returns AstExpressionString
	 *     AstExpressionAssertion returns AstExpressionString
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionString
	 *     AstExpressionPostfix returns AstExpressionString
	 *     AstExpressionLiteral returns AstExpressionString
	 *     AstExpressionString returns AstExpressionString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AstExpressionString(ISerializationContext context, AstExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_EXPRESSION_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_EXPRESSION_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstExpressionStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionSymbolReference
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionAnd returns AstExpressionSymbolReference
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionBitor returns AstExpressionSymbolReference
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionBitxor returns AstExpressionSymbolReference
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionBitand returns AstExpressionSymbolReference
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionEq returns AstExpressionSymbolReference
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionRelational returns AstExpressionSymbolReference
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionShift returns AstExpressionSymbolReference
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionAdditive returns AstExpressionSymbolReference
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionMultiplicative returns AstExpressionSymbolReference
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionExp returns AstExpressionSymbolReference
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionSymbolReference
	 *     AstExpressionUnary returns AstExpressionSymbolReference
	 *     AstExpressionAssertion returns AstExpressionSymbolReference
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionSymbolReference
	 *     AstExpressionPostfix returns AstExpressionSymbolReference
	 *     AstExpressionSymbolReference returns AstExpressionSymbolReference
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         symbol=[AstVariable|ID] 
	 *         indexes+=AstExpression* 
	 *         member+=AstMemberAccess* 
	 *         ctor=ID? 
	 *         (call?='(' (parameters+=AstExpression parameters+=AstExpression*)?)?
	 *     )
	 */
	protected void sequence_AstExpressionSymbolReference(ISerializationContext context, AstExpressionSymbolReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionUnary
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionAnd returns AstExpressionUnary
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionBitor returns AstExpressionUnary
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionBitxor returns AstExpressionUnary
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionBitand returns AstExpressionUnary
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionEq returns AstExpressionUnary
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionRelational returns AstExpressionUnary
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionShift returns AstExpressionUnary
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionAdditive returns AstExpressionUnary
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionMultiplicative returns AstExpressionUnary
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionExp returns AstExpressionUnary
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionUnary
	 *     AstExpressionUnary returns AstExpressionUnary
	 *     AstExpressionAssertion returns AstExpressionUnary
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionUnary
	 *     AstExpressionPostfix returns AstExpressionUnary
	 *
	 * Constraint:
	 *     ((unaryOperator='~' | unaryOperator='-' | unaryOperator='not' | unaryOperator='#' | unaryOperator='old') expression=AstExpressionPostfix)
	 */
	protected void sequence_AstExpressionUnary(ISerializationContext context, AstExpressionUnary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns AstExpressionBinary
	 *     AstExpression.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionAnd returns AstExpressionBinary
	 *     AstExpressionAnd.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionBitor returns AstExpressionBinary
	 *     AstExpressionBitor.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionBitxor returns AstExpressionBinary
	 *     AstExpressionBitxor.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionBitand returns AstExpressionBinary
	 *     AstExpressionBitand.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionEq returns AstExpressionBinary
	 *     AstExpressionEq.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionRelational returns AstExpressionBinary
	 *     AstExpressionRelational.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionShift returns AstExpressionBinary
	 *     AstExpressionShift.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionAdditive returns AstExpressionBinary
	 *     AstExpressionAdditive.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionMultiplicative returns AstExpressionBinary
	 *     AstExpressionMultiplicative.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionExp returns AstExpressionBinary
	 *     AstExpressionExp.AstExpressionBinary_1_0 returns AstExpressionBinary
	 *     AstExpressionUnary returns AstExpressionBinary
	 *     AstExpressionAssertion returns AstExpressionBinary
	 *     AstExpressionAssertion.AstExpressionAssertion_1_0_0_0 returns AstExpressionBinary
	 *     AstExpressionPostfix returns AstExpressionBinary
	 *
	 * Constraint:
	 *     (
	 *         (left=AstExpression_AstExpressionBinary_1_0 (operator='||' | operator='or' | operator='..') right=AstExpressionAnd) | 
	 *         (left=AstExpressionAnd_AstExpressionBinary_1_0 (operator='&&' | operator='and') right=AstExpressionBitor) | 
	 *         (left=AstExpressionBitor_AstExpressionBinary_1_0 operator='|' right=AstExpressionBitxor) | 
	 *         (left=AstExpressionBitxor_AstExpressionBinary_1_0 operator='^' right=AstExpressionBitand) | 
	 *         (left=AstExpressionBitand_AstExpressionBinary_1_0 operator='&' right=AstExpressionEq) | 
	 *         (left=AstExpressionEq_AstExpressionBinary_1_0 (operator='=' | operator='!=') right=AstExpressionRelational) | 
	 *         (left=AstExpressionRelational_AstExpressionBinary_1_0 (operator='<' | operator='<=' | operator='>' | operator='>=') right=AstExpressionShift) | 
	 *         (left=AstExpressionShift_AstExpressionBinary_1_0 (operator='<<' | operator='>>' | operator='>>>') right=AstExpressionAdditive) | 
	 *         (left=AstExpressionAdditive_AstExpressionBinary_1_0 (operator='+' | operator='-') right=AstExpressionMultiplicative) | 
	 *         (
	 *             left=AstExpressionMultiplicative_AstExpressionBinary_1_0 
	 *             (operator='*' | operator='/' | operator='div' | operator='mod') 
	 *             right=AstExpressionExp
	 *         ) | 
	 *         (left=AstExpressionExp_AstExpressionBinary_1_0 operator='**' right=AstExpressionUnary)
	 *     )
	 */
	protected void sequence_AstExpression_AstExpressionAdditive_AstExpressionAnd_AstExpressionBitand_AstExpressionBitor_AstExpressionBitxor_AstExpressionEq_AstExpressionExp_AstExpressionMultiplicative_AstExpressionRelational_AstExpressionShift(ISerializationContext context, AstExpressionBinary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAbstractActor returns AstExternalActor
	 *     AstExternalActor returns AstExternalActor
	 *
	 * Constraint:
	 *     (name=ID (parameters+=AstParameter parameters+=AstParameter*)? (inputs+=AstPort inputs+=AstPort*)? (outputs+=AstPort outputs+=AstPort*)?)
	 */
	protected void sequence_AstExternalActor(ISerializationContext context, AstExternalActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExternalFunction returns AstFunction
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* name=ID (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)? type=AstType)
	 */
	protected void sequence_AstExternalFunction(ISerializationContext context, AstFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExternalProcedure returns AstProcedure
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* name=ID (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)?)
	 */
	protected void sequence_AstExternalProcedure(ISerializationContext context, AstProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstForeachGenerator returns AstForeachGenerator
	 *
	 * Constraint:
	 *     (variable=AstVariableDeclaration expression=AstExpression)
	 */
	protected void sequence_AstForeachGenerator(ISerializationContext context, AstForeachGenerator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_FOREACH_GENERATOR__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_FOREACH_GENERATOR__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_FOREACH_GENERATOR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_FOREACH_GENERATOR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstForeachGeneratorAccess().getVariableAstVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAstForeachGeneratorAccess().getExpressionAstExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstFunction returns AstFunction
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         name=ID 
	 *         (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)? 
	 *         type=AstType 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         expression=AstExpression?
	 *     )
	 */
	protected void sequence_AstFunction(ISerializationContext context, AstFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstGenerator returns AstGenerator
	 *
	 * Constraint:
	 *     (variable=AstVariableDeclaration expression=AstExpression filter+=AstExpression*)
	 */
	protected void sequence_AstGenerator(ISerializationContext context, AstGenerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstInequality returns AstInequality
	 *
	 * Constraint:
	 *     (tags+=AstTag tags+=AstTag+)
	 */
	protected void sequence_AstInequality(ISerializationContext context, AstInequality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstInitialize returns AstInitialize
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         tag=AstTag? 
	 *         (outputs+=AstOutputExpression outputs+=AstOutputExpression*)? 
	 *         (guards+=AstExpression guards+=AstExpression*)? 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStatement*
	 *     )
	 */
	protected void sequence_AstInitialize(ISerializationContext context, AstInitialize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstInputPattern returns AstInputPattern
	 *
	 * Constraint:
	 *     (port=[AstPort|ID]? tokens+=AstPattern tokens+=AstPattern* repeat=AstExpression?)
	 */
	protected void sequence_AstInputPattern(ISerializationContext context, AstInputPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstInvariant returns AstInvariant
	 *
	 * Constraint:
	 *     (invariants+=AstExpression invariants+=AstExpression*)
	 */
	protected void sequence_AstInvariant(ISerializationContext context, AstInvariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstLValue returns AstLValue
	 *
	 * Constraint:
	 *     (target=[AstVariable|ID] indexes+=AstExpression* member+=AstMemberAccess*)
	 */
	protected void sequence_AstLValue(ISerializationContext context, AstLValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstMemberAccess returns AstMemberAccess
	 *
	 * Constraint:
	 *     (name=ID memberIndex+=AstExpression*)
	 */
	protected void sequence_AstMemberAccess(ISerializationContext context, AstMemberAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstNamespace returns AstNamespace
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         name=QualifiedName 
	 *         (
	 *             functions+=AstFunction | 
	 *             procedures+=AstProcedure | 
	 *             variables+=AstConstantVariable | 
	 *             externals+=AstExternalVariable | 
	 *             externals+=AstExternalFunction | 
	 *             externals+=AstExternalProcedure | 
	 *             typedefs+=AstTypeDefinition | 
	 *             imports+=Import | 
	 *             entities+=AstEntity | 
	 *             namespaces+=AstNamespace
	 *         )*
	 *     )
	 */
	protected void sequence_AstNamespace(ISerializationContext context, AstNamespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompilationUnit returns AstNamespace
	 *
	 * Constraint:
	 *     (
	 *         (rvc?='package' name=QualifiedName (entities+=AstEntity | imports+=RvcImport | units+=AstUnit)*) | 
	 *         (
	 *             annotations+=AstAnnotation* 
	 *             name=QualifiedName 
	 *             (
	 *                 functions+=AstFunction | 
	 *                 procedures+=AstProcedure | 
	 *                 variables+=AstConstantVariable | 
	 *                 externals+=AstExternalVariable | 
	 *                 externals+=AstExternalFunction | 
	 *                 externals+=AstExternalProcedure | 
	 *                 typedefs+=AstTypeDefinition | 
	 *                 imports+=Import | 
	 *                 entities+=AstEntity | 
	 *                 namespaces+=AstNamespace
	 *             )*
	 *         )
	 *     )
	 */
	protected void sequence_AstNamespace_AstPackage(ISerializationContext context, AstNamespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAbstractActor returns AstNetwork
	 *     AstNetwork returns AstNetwork
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=AstParameter parameters+=AstParameter*)? 
	 *         (inputs+=AstPort inputs+=AstPort*)? 
	 *         (outputs+=AstPort outputs+=AstPort*)? 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         entities+=AstEntityDeclaration+ 
	 *         structure=AstStructure?
	 *     )
	 */
	protected void sequence_AstNetwork(ISerializationContext context, AstNetwork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstOutputExpression returns AstOutputExpression
	 *
	 * Constraint:
	 *     (port=[AstPort|ID]? values+=AstExpression values+=AstExpression* repeat=AstExpression?)
	 */
	protected void sequence_AstOutputExpression(ISerializationContext context, AstOutputExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPackage returns AstNamespace
	 *
	 * Constraint:
	 *     (rvc?='package' name=QualifiedName (entities+=AstEntity | imports+=RvcImport | units+=AstUnit)*)
	 */
	protected void sequence_AstPackage(ISerializationContext context, AstNamespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstParameter returns AstVariable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression* value=AstExpression?)
	 */
	protected void sequence_AstParameter_AstVariableDeclaration(ISerializationContext context, AstVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternAlias returns AstPattern
	 *
	 * Constraint:
	 *     ((alias=AstPatternDeclaration | alias=AstPatternWildcard) expression=AstPatternExpression)
	 */
	protected void sequence_AstPatternAlias(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPattern returns AstPattern
	 *
	 * Constraint:
	 *     (
	 *         variable=AstToken | 
	 *         (
	 *             (patterns+=AstPatternLiteral | patterns+=AstPatternExpression) 
	 *             patterns+=AstPatternLiteral? 
	 *             (patterns+=AstPatternExpression? patterns+=AstPatternLiteral?)*
	 *         ) | 
	 *         ((alias=AstPatternDeclaration | alias=AstPatternWildcard) expression=AstPatternExpression) | 
	 *         (patterns+=AstPattern patterns+=AstPattern*) | 
	 *         (name=ID patterns+=AstPattern patterns+=AstPattern*)
	 *     )?
	 */
	protected void sequence_AstPatternAlias_AstPatternAlternative_AstPatternDeclaration_AstPatternDeconstruction_AstPatternList_AstPatternWildcard(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternAlternative returns AstPattern
	 *
	 * Constraint:
	 *     (
	 *         (patterns+=AstPatternLiteral | patterns+=AstPatternExpression) 
	 *         patterns+=AstPatternLiteral? 
	 *         (patterns+=AstPatternExpression? patterns+=AstPatternLiteral?)*
	 *     )
	 */
	protected void sequence_AstPatternAlternative(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternDeclaration returns AstPattern
	 *
	 * Constraint:
	 *     variable=AstToken
	 */
	protected void sequence_AstPatternDeclaration(ISerializationContext context, AstPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_PATTERN__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_PATTERN__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstPatternDeclarationAccess().getVariableAstTokenParserRuleCall_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternDeconstruction returns AstPattern
	 *
	 * Constraint:
	 *     (name=ID patterns+=AstPattern patterns+=AstPattern*)
	 */
	protected void sequence_AstPatternDeconstruction(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternExpression returns AstPattern
	 *
	 * Constraint:
	 *     (expression=AstExpression | expression=AstExpressionSymbolReference)
	 */
	protected void sequence_AstPatternExpression(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternList returns AstPattern
	 *
	 * Constraint:
	 *     (patterns+=AstPattern patterns+=AstPattern*)
	 */
	protected void sequence_AstPatternList(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternLiteral returns AstPattern
	 *
	 * Constraint:
	 *     literal=AstExpressionLiteral
	 */
	protected void sequence_AstPatternLiteral(ISerializationContext context, AstPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_PATTERN__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_PATTERN__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstPatternLiteralAccess().getLiteralAstExpressionLiteralParserRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstPatternWildcard returns AstPattern
	 *
	 * Constraint:
	 *     {AstPattern}
	 */
	protected void sequence_AstPatternWildcard(ISerializationContext context, AstPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPort returns AstPort
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID)
	 */
	protected void sequence_AstPort(ISerializationContext context, AstPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPriority returns AstPriority
	 *
	 * Constraint:
	 *     inequalities+=AstInequality*
	 */
	protected void sequence_AstPriority(ISerializationContext context, AstPriority semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstProcedure returns AstProcedure
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         name=ID 
	 *         (parameters+=AstVariableDeclaration parameters+=AstVariableDeclaration*)? 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStatement*
	 *     )
	 */
	protected void sequence_AstProcedure(ISerializationContext context, AstProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstProcessDescription returns AstProcessDescription
	 *
	 * Constraint:
	 *     (repeated?='repeat'? statements+=AstStatement*)
	 */
	protected void sequence_AstProcessDescription(ISerializationContext context, AstProcessDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstScheduleRegExp returns RegExp
	 *
	 * Constraint:
	 *     exp=RegExp
	 */
	protected void sequence_AstScheduleRegExp(ISerializationContext context, RegExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.REG_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.REG_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstScheduleRegExpAccess().getExpRegExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstSchedule returns AstSchedule
	 *
	 * Constraint:
	 *     (initialState=[AstState|ID] transitions+=AstTransition*)
	 */
	protected void sequence_AstSchedule(ISerializationContext context, AstSchedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstState returns AstState
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AstState(ISerializationContext context, AstState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstStateAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementAlternative returns AstStatementAlternative
	 *
	 * Constraint:
	 *     (pattern=AstPattern (guards+=AstExpression guards+=AstExpression*)? statements+=AstStatement*)
	 */
	protected void sequence_AstStatementAlternative(ISerializationContext context, AstStatementAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementAssign returns AstStatementAssign
	 *     AstStatement returns AstStatementAssign
	 *
	 * Constraint:
	 *     (lvalue=AstLValue value=AstExpression)
	 */
	protected void sequence_AstStatementAssign(ISerializationContext context, AstStatementAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_STATEMENT_ASSIGN__LVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_STATEMENT_ASSIGN__LVALUE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_STATEMENT_ASSIGN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_STATEMENT_ASSIGN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstStatementAssignAccess().getLvalueAstLValueParserRuleCall_0_0(), semanticObject.getLvalue());
		feeder.accept(grammarAccess.getAstStatementAssignAccess().getValueAstExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementBlock returns AstStatementBlock
	 *     AstStatement returns AstStatementBlock
	 *
	 * Constraint:
	 *     ((variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? statements+=AstStatement*)
	 */
	protected void sequence_AstStatementBlock(ISerializationContext context, AstStatementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementCall returns AstStatementCall
	 *     AstStatement returns AstStatementCall
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* procedure=[AstProcedure|ID] (parameters+=AstExpression parameters+=AstExpression*)?)
	 */
	protected void sequence_AstStatementCall(ISerializationContext context, AstStatementCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementCase returns AstStatementCase
	 *     AstStatement returns AstStatementCase
	 *
	 * Constraint:
	 *     (expression=AstExpressionSymbolReference cases+=AstStatementAlternative+ default=AstStatement?)
	 */
	protected void sequence_AstStatementCase(ISerializationContext context, AstStatementCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementElsif returns AstStatementElsif
	 *
	 * Constraint:
	 *     (condition=AstExpression then+=AstStatement*)
	 */
	protected void sequence_AstStatementElsif(ISerializationContext context, AstStatementElsif semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementForeach returns AstStatementForeach
	 *     AstStatement returns AstStatementForeach
	 *
	 * Constraint:
	 *     (
	 *         generators+=AstForeachGenerator 
	 *         generators+=AstForeachGenerator* 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStatement*
	 *     )
	 */
	protected void sequence_AstStatementForeach(ISerializationContext context, AstStatementForeach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementIf returns AstStatementIf
	 *     AstStatement returns AstStatementIf
	 *
	 * Constraint:
	 *     (condition=AstExpression then+=AstStatement* elsifs+=AstStatementElsif* else+=AstStatement*)
	 */
	protected void sequence_AstStatementIf(ISerializationContext context, AstStatementIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementRead returns AstStatementRead
	 *     AstStatement returns AstStatementRead
	 *
	 * Constraint:
	 *     (port=[AstPort|ID] lvalues+=AstLValue lvalues+=AstLValue* repeat=AstExpression?)
	 */
	protected void sequence_AstStatementRead(ISerializationContext context, AstStatementRead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementWhile returns AstStatementWhile
	 *     AstStatement returns AstStatementWhile
	 *
	 * Constraint:
	 *     (condition=AstExpression statements+=AstStatement*)
	 */
	protected void sequence_AstStatementWhile(ISerializationContext context, AstStatementWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStatementWrite returns AstStatementWrite
	 *     AstStatement returns AstStatementWrite
	 *
	 * Constraint:
	 *     (port=[AstPort|ID] values+=AstExpression values+=AstExpression* repeat=AstExpression?)
	 */
	protected void sequence_AstStatementWrite(ISerializationContext context, AstStatementWrite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStructureStatement returns AstStructureStatementConnection
	 *     AstStructureStatementConnection returns AstStructureStatementConnection
	 *
	 * Constraint:
	 *     (
	 *         (from=AstEntityVariableReference fromIndexes+=AstExpression*)? 
	 *         outPort=ID 
	 *         (to=AstEntityVariableReference fromIndexes+=AstExpression*)? 
	 *         inPort=ID 
	 *         attribute+=AstConnectionAttribute*
	 *     )
	 */
	protected void sequence_AstStructureStatementConnection(ISerializationContext context, AstStructureStatementConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStructureStatementElsif returns AstStructureStatementElsif
	 *
	 * Constraint:
	 *     (condition=AstExpression then+=AstStructureStatement*)
	 */
	protected void sequence_AstStructureStatementElsif(ISerializationContext context, AstStructureStatementElsif semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStructureStatement returns AstStructureStatementForeach
	 *     AstStructureStatementForeach returns AstStructureStatementForeach
	 *
	 * Constraint:
	 *     (
	 *         generators+=AstForeachGenerator 
	 *         generators+=AstForeachGenerator* 
	 *         (variables+=AstValuedVariableDeclaration variables+=AstValuedVariableDeclaration*)? 
	 *         statements+=AstStructureStatement*
	 *     )
	 */
	protected void sequence_AstStructureStatementForeach(ISerializationContext context, AstStructureStatementForeach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStructureStatement returns AstStructureStatementIf
	 *     AstStructureStatementIf returns AstStructureStatementIf
	 *
	 * Constraint:
	 *     (condition=AstExpression then+=AstStructureStatement* elsifs+=AstStructureStatementElsif* else+=AstStructureStatement*)
	 */
	protected void sequence_AstStructureStatementIf(ISerializationContext context, AstStructureStatementIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStructure returns AstStructure
	 *
	 * Constraint:
	 *     connections+=AstStructureStatement+
	 */
	protected void sequence_AstStructure(ISerializationContext context, AstStructure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTag returns AstTag
	 *
	 * Constraint:
	 *     (identifiers+=ID identifiers+=ID*)
	 */
	protected void sequence_AstTag(ISerializationContext context, AstTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTaggedTuple returns AstTaggedTuple
	 *
	 * Constraint:
	 *     (name=ID (fields+=AstValuedVariableDeclaration fields+=AstValuedVariableDeclaration*)?)
	 */
	protected void sequence_AstTaggedTuple(ISerializationContext context, AstTaggedTuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstToken returns AstVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AstToken(ISerializationContext context, AstVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstTokenAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstTransition returns AstTransition
	 *
	 * Constraint:
	 *     (source=[AstState|ID] tags+=AstTag tags+=AstTag* target=[AstState|ID])
	 */
	protected void sequence_AstTransition(ISerializationContext context, AstTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTuple returns AstTuple
	 *
	 * Constraint:
	 *     (fields+=AstValuedVariableDeclaration fields+=AstValuedVariableDeclaration*)?
	 */
	protected void sequence_AstTuple(ISerializationContext context, AstTuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeDefinitionParameter returns AstTypeDefinitionParameter
	 *
	 * Constraint:
	 *     (value=AstVariableDeclaration | type=AstTypeDefinitionTypeParameter)
	 */
	protected void sequence_AstTypeDefinitionParameter(ISerializationContext context, AstTypeDefinitionParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeDefinitionTypeParameter returns AstTypeUser
	 *
	 * Constraint:
	 *     (variable?='type' name=ID)
	 */
	protected void sequence_AstTypeDefinitionTypeParameter(ISerializationContext context, AstTypeUser semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_TYPE_USER__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_TYPE_USER__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstTypeDefinitionTypeParameterAccess().getVariableTypeKeyword_0_0(), semanticObject.isVariable());
		feeder.accept(grammarAccess.getAstTypeDefinitionTypeParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeDefinition returns AstTypeUser
	 *
	 * Constraint:
	 *     (
	 *         definition?='type' 
	 *         name=ID 
	 *         (parameters+=AstTypeDefinitionParameter parameters+=AstTypeDefinitionParameter*)? 
	 *         (tuples+=AstTuple | (tuples+=AstTaggedTuple tuples+=AstTaggedTuple*))
	 *     )
	 */
	protected void sequence_AstTypeDefinition(ISerializationContext context, AstTypeUser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeParam returns AstTypeParam
	 *
	 * Constraint:
	 *     ((name=ID value=AstExpression) | ((name=ID | name='type') type=AstType))
	 */
	protected void sequence_AstTypeParam(ISerializationContext context, AstTypeParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeParameterList returns AstTypeParameterList
	 *
	 * Constraint:
	 *     (params+=AstTypeParam params+=AstTypeParam*)
	 */
	protected void sequence_AstTypeParameterList(ISerializationContext context, AstTypeParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTypeUser returns AstTypeUser
	 *
	 * Constraint:
	 *     {AstTypeUser}
	 */
	protected void sequence_AstTypeUser(ISerializationContext context, AstTypeUser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstType
	 *
	 * Constraint:
	 *     (
	 *         (builtin=AstTypeBuiltIn typeParams=AstTypeParameterList? dimensions+=AstExpression*) | 
	 *         (name=[AstTypeUser|ID] typeParams=AstTypeParameterList? dimensions+=AstExpression*) | 
	 *         ((domain+=AstType domain+=AstType*)? codomain=AstType?)
	 *     )
	 */
	protected void sequence_AstType(ISerializationContext context, AstType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstUnit returns AstNamespace
	 *
	 * Constraint:
	 *     (
	 *         rvc?='unit' 
	 *         name=QualifiedName 
	 *         (
	 *             functions+=AstFunction | 
	 *             procedures+=AstProcedure | 
	 *             variables+=AstConstantVariable | 
	 *             externals+=AstExternalVariable | 
	 *             externals+=AstExternalFunction | 
	 *             externals+=AstExternalProcedure
	 *         )*
	 *     )
	 */
	protected void sequence_AstUnit(ISerializationContext context, AstNamespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstStateVariable returns AstVariable
	 *     AstValuedVariableDeclaration returns AstVariable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression* (constant?='='? value=AstExpression)?)
	 */
	protected void sequence_AstValuedVariableDeclaration_AstVariableDeclaration(ISerializationContext context, AstVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExternalVariable returns AstVariable
	 *     AstVariableDeclaration returns AstVariable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression*)
	 */
	protected void sequence_AstVariableDeclaration(ISerializationContext context, AstVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns GroupImportTail
	 *     GroupImportTail returns GroupImportTail
	 *
	 * Constraint:
	 *     (kind=ImportKind? importedNamespace=QualifiedName)
	 */
	protected void sequence_GroupImportTail(ISerializationContext context, GroupImportTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (key=AstExpression value=AstExpression)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.MAPPING__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.MAPPING__KEY));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.MAPPING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.MAPPING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getKeyAstExpressionParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMappingAccess().getValueAstExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpUnary
	 *     RegExp.RegExpBinary_1_0 returns RegExpUnary
	 *     RegExpConcatenation returns RegExpUnary
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpUnary
	 *     RegExpPostfix returns RegExpUnary
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpUnary
	 *     RegExpGrouping returns RegExpUnary
	 *
	 * Constraint:
	 *     (child=RegExpPostfix_RegExpUnary_1_0 (unaryOperator='*' | unaryOperator='?'))
	 */
	protected void sequence_RegExpPostfix(ISerializationContext context, RegExpUnary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpTag
	 *     RegExp.RegExpBinary_1_0 returns RegExpTag
	 *     RegExpConcatenation returns RegExpTag
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpTag
	 *     RegExpPostfix returns RegExpTag
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpTag
	 *     RegExpGrouping returns RegExpTag
	 *     RegExpTerminal returns RegExpTag
	 *
	 * Constraint:
	 *     tag=AstTag
	 */
	protected void sequence_RegExpTerminal(ISerializationContext context, RegExpTag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.REG_EXP_TAG__TAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.REG_EXP_TAG__TAG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegExpTerminalAccess().getTagAstTagParserRuleCall_1_0(), semanticObject.getTag());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpBinary
	 *     RegExp.RegExpBinary_1_0 returns RegExpBinary
	 *     RegExpConcatenation returns RegExpBinary
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpBinary
	 *     RegExpPostfix returns RegExpBinary
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpBinary
	 *     RegExpGrouping returns RegExpBinary
	 *
	 * Constraint:
	 *     ((left=RegExp_RegExpBinary_1_0 operator='|' right=RegExpConcatenation) | (left=RegExpConcatenation_RegExpBinary_1_0 right=RegExpPostfix))
	 */
	protected void sequence_RegExp_RegExpConcatenation(ISerializationContext context, RegExpBinary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RvcImport returns RvcImport
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard
	 */
	protected void sequence_RvcImport(ISerializationContext context, RvcImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.RVC_IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.RVC_IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRvcImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns SingleImportTail
	 *     SingleImportTail returns SingleImportTail
	 *
	 * Constraint:
	 *     (kind=ImportKind? importedNamespace=QualifiedName localNameToken=ID?)
	 */
	protected void sequence_SingleImportTail(ISerializationContext context, SingleImportTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
